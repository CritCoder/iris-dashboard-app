import jsPDF from 'jspdf';

// PDF Export utility for posts and reports
export const exportPostsToPDF = async (posts: any[], filters: any, searchQuery: string) => {
  console.log('Starting PDF export with:', { postsCount: posts.length, filters, searchQuery });
  
  const doc = new jsPDF();
  
  // Add title
  doc.setFontSize(20);
  doc.setTextColor(0, 150, 255); // Cyan color
  doc.text('OSINT Intelligence - Posts Export', 20, 20);
  
  // Add export info
  doc.setFontSize(12);
  doc.setTextColor(100, 100, 100);
  doc.text(`Exported on: ${new Date().toLocaleString()}`, 20, 30);
  doc.text(`Total Posts: ${posts.length}`, 20, 40);
  
  // Add filters info
  let filterY = 50;
  if (Object.keys(filters).length > 0 || searchQuery) {
    doc.setTextColor(150, 150, 150);
    doc.text('Applied Filters:', 20, filterY);
    filterY += 10;
    
    if (searchQuery) {
      doc.text(`Search: ${searchQuery}`, 25, filterY);
      filterY += 8;
    }
    
    Object.entries(filters).forEach(([key, value]) => {
      if (value && value !== 'all') {
        const filterLabel = getFilterLabel(key, value as string);
        doc.text(filterLabel, 25, filterY);
        filterY += 8;
      }
    });
  }
  
  // Add posts table
  const tableY = filterY + 10;
  
  // Add table subtitle
  doc.setFontSize(14);
  doc.setTextColor(0, 150, 255);
  doc.text('Posts Data', 20, tableY);
  
  // Add a subtle line
  doc.setDrawColor(0, 150, 255);
  doc.setLineWidth(0.3);
  doc.line(20, tableY + 5, 80, tableY + 5);
  
  const actualTableY = tableY + 20;
  
  // Prepare table data
  const tableData = posts.map(post => [
    post.social_profile?.username || post.person?.name || 'Unknown',
    post.postedAt ? new Date(post.postedAt).toLocaleDateString() : 'Unknown',
    post.social_profile?.platform || post.platform || 'Unknown',
    post.url || 'No URL',
    post.aiSentiment || 'Unknown'
  ]);
  
  // Add table headers
  const headers = [
    'Author Name',
    'Post Date', 
    'Social Platform',
    'Post URL',
    'Sentiment Analysis'
  ];
  
  createSimpleTable(doc, headers, tableData, actualTableY);
  
  // Add footer
  const estimatedTableHeight = (tableData.length + 1) * 15;
  let finalY = actualTableY + estimatedTableHeight + 20;
  
  if (finalY > doc.internal.pageSize.height - 30) {
    doc.addPage();
    finalY = 20;
  }
  
  doc.setFontSize(10);
  doc.setTextColor(100, 100, 100);
  doc.text('Generated by OSINT Intelligence Platform', 20, finalY);
  
  // Save the PDF
  const filename = `osint-posts-export-${new Date().toISOString().split('T')[0]}.pdf`;
  doc.save(filename);
  
  console.log('PDF saved successfully:', filename);
};

const createSimpleTable = (doc: jsPDF, headers: string[], data: any[][], startY: number) => {
  const pageWidth = doc.internal.pageSize.width;
  const margin = 20;
  const availableWidth = pageWidth - (2 * margin);
  
  const colWidths = [
    availableWidth * 0.20,
    availableWidth * 0.15,
    availableWidth * 0.15,
    availableWidth * 0.30,
    availableWidth * 0.20
  ];
  
  const rowHeight = 15;
  let currentY = startY;
  
  if (currentY + (data.length + 1) * rowHeight > doc.internal.pageSize.height - 40) {
    doc.addPage();
    currentY = 20;
  }
  
  const tableWidth = colWidths.reduce((sum, width) => sum + width, 0);
  const tableHeight = (data.length + 1) * rowHeight;
  
  doc.setDrawColor(0, 150, 255);
  doc.setLineWidth(0.5);
  doc.rect(margin, currentY, tableWidth, tableHeight);
  
  // Draw headers
  doc.setFillColor(0, 150, 255);
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  
  let currentX = margin;
  headers.forEach((header, index) => {
    doc.rect(currentX, currentY, colWidths[index], rowHeight, 'F');
    const textWidth = doc.getTextWidth(header);
    const textX = currentX + (colWidths[index] - textWidth) / 2;
    doc.text(header, textX, currentY + 10);
    
    if (index < headers.length - 1) {
      doc.setDrawColor(255, 255, 255);
      doc.setLineWidth(0.2);
      doc.line(currentX + colWidths[index], currentY, currentX + colWidths[index], currentY + rowHeight);
    }
    
    currentX += colWidths[index];
  });
  
  doc.setDrawColor(0, 150, 255);
  doc.setLineWidth(0.5);
  doc.line(margin, currentY + rowHeight, margin + tableWidth, currentY + rowHeight);
  
  currentY += rowHeight;
  
  // Draw data rows
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(50, 50, 50);
  
  data.forEach((row) => {
    if (currentY + rowHeight > doc.internal.pageSize.height - 40) {
      doc.addPage();
      currentY = 20;
    }
    
    currentX = margin;
    row.forEach((cell, colIndex) => {
      let displayText = String(cell);
      
      if (colIndex === 3 && displayText.length > 35) {
        displayText = displayText.substring(0, 32) + '...';
      } else if (colIndex === 0 && displayText.length > 20) {
        displayText = displayText.substring(0, 17) + '...';
      }
      
      doc.text(displayText, currentX + 3, currentY + 10);
      
      if (colIndex < row.length - 1) {
        doc.setDrawColor(200, 200, 200);
        doc.setLineWidth(0.1);
        doc.line(currentX + colWidths[colIndex], currentY, currentX + colWidths[colIndex], currentY + rowHeight);
      }
      
      currentX += colWidths[colIndex];
    });
    
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.1);
    doc.line(margin, currentY + rowHeight, margin + tableWidth, currentY + rowHeight);
    
    currentY += rowHeight;
  });
  
  return currentY;
};

const getFilterLabel = (key: string, value: string): string => {
  const filterLabels: Record<string, string> = {
    sentiment: `Sentiment: ${value}`,
    platform: `Platform: ${value}`,
    hasMedia: `Media: ${value === 'true' ? 'Has Media' : 'No Media'}`,
    min_likesCount: `Min Likes: ${value}+`,
    min_commentsCount: `Min Comments: ${value}+`,
    min_sharesCount: `Min Shares: ${value}+`,
    min_viewsCount: `Min Views: ${value}+`,
    timeRange: `Time Range: ${getTimeRangeLabel(value)}`,
    startDate: `Start Date: ${value}`,
    endDate: `End Date: ${value}`
  };
  
  return filterLabels[key] || `${key}: ${value}`;
};

const getTimeRangeLabel = (value: string): string => {
  const timeLabels: Record<string, string> = {
    '24h': 'Last 24 Hours',
    '1w': 'Last Week',
    '1m': 'Last Month',
    'all': 'All Time'
  };
  
  return timeLabels[value] || value;
};

export const exportAllPostsToPDF = async (
  fetchPostsFunction: (page: number, limit: number, filters: any) => Promise<any>,
  filters: any,
  searchQuery: string,
  maxPosts = 5000,
  onProgress?: (message: string, progress: number) => void
) => {
  try {
    let allPosts: any[] = [];
    let currentPage = 1;
    let hasMore = true;
    
    console.log('Fetching posts for export...');
    if (onProgress) onProgress('Starting export...', 0);
    
    while (hasMore && allPosts.length < maxPosts) {
      if (onProgress) {
        onProgress(`Fetching page ${currentPage}...`, Math.min((allPosts.length / maxPosts) * 100, 90));
      }
      
      const response = await fetchPostsFunction(currentPage, 100, filters);
      
      if (response.success && response.data) {
        const newPosts = response.data;
        allPosts = [...allPosts, ...newPosts];
        hasMore = response.pagination?.hasNext || false;
        currentPage++;
        await new Promise(resolve => setTimeout(resolve, 100));
      } else {
        hasMore = false;
      }
    }
    
    if (allPosts.length === 0) {
      throw new Error('No posts found to export');
    }
    
    if (onProgress) onProgress('Generating PDF...', 95);
    await exportPostsToPDF(allPosts, filters, searchQuery);
    if (onProgress) onProgress('Export complete!', 100);
    
    return allPosts.length;
  } catch (error) {
    console.error('Failed to export all posts:', error);
    throw error;
  }
};

